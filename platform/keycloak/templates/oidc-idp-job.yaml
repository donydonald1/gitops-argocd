{{- if .Values.oidcIdp.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: keycloak-oidc-idp-setup
  labels:
    app.kubernetes.io/name: keycloakx
    app.kubernetes.io/instance: {{ .Release.Name }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  ttlSecondsAfterFinished: 300
  template:
    spec:
      restartPolicy: OnFailure
      containers:
      - name: oidc-setup
        image: curlimages/curl:latest
        env:
        - name: KEYCLOAK_URL
          value: "http://keycloakx-http.{{ .Release.Namespace }}.svc.cluster.local"
        - name: KEYCLOAK_HEALTH_URL
          value: "http://keycloakx-http.{{ .Release.Namespace }}.svc.cluster.local:9000"
        - name: ADMIN_USER
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: username
        - name: ADMIN_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keycloak-admin-creds
              key: password
        - name: OIDC_CLIENT_ID
          valueFrom:
            secretKeyRef:
              name: keycloak-oidc-creds
              key: clientId
        - name: OIDC_CLIENT_SECRET
          valueFrom:
            secretKeyRef:
              name: keycloak-oidc-creds
              key: clientSecret
        - name: OIDC_ISSUER
          valueFrom:
            secretKeyRef:
              name: keycloak-oidc-creds
              key: issuer
        - name: OIDC_AUTH_ENDPOINT
          valueFrom:
            secretKeyRef:
              name: keycloak-oidc-creds
              key: authEndpoint
        - name: OIDC_TOKEN_ENDPOINT
          valueFrom:
            secretKeyRef:
              name: keycloak-oidc-creds
              key: tokenEndpoint
        - name: OIDC_USERINFO_ENDPOINT
          valueFrom:
            secretKeyRef:
              name: keycloak-oidc-creds
              key: userInfoEndpoint
        - name: OIDC_JWKS_URI
          valueFrom:
            secretKeyRef:
              name: keycloak-oidc-creds
              key: jwksUri
        - name: OIDC_END_SESSION_ENDPOINT
          valueFrom:
            secretKeyRef:
              name: keycloak-oidc-creds
              key: endSessionEndpoint
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "Waiting for Keycloak to be ready..."
          until curl -sf "${KEYCLOAK_HEALTH_URL}/health/ready"; do
            echo "Keycloak not ready, waiting..."
            sleep 5
          done
          echo "Keycloak is ready"

          echo "Getting admin token..."
          TOKEN=$(curl -sf -X POST "${KEYCLOAK_URL}/realms/master/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=${ADMIN_USER}" \
            -d "password=${ADMIN_PASSWORD}" \
            -d "grant_type=password" \
            -d "client_id=admin-cli" | sed 's/.*"access_token":"\([^"]*\)".*/\1/')

          if [ -z "$TOKEN" ]; then
            echo "Failed to get admin token"
            exit 1
          fi

          echo "Checking if IDP exists..."
          # Use -s (silent) without -f (fail) to capture HTTP status code even on 404
          IDP_EXISTS=$(curl -s -o /dev/null -w "%{http_code}" \
            "${KEYCLOAK_URL}/admin/realms/master/identity-provider/instances/unifi-identity" \
            -H "Authorization: Bearer ${TOKEN}")

          IDP_CONFIG='{
            "alias": "unifi-identity",
            "displayName": "Techsecom SSO",
            "providerId": "oidc",
            "enabled": true,
            "trustEmail": true,
            "storeToken": true,
            "addReadTokenRoleOnCreate": false,
            "firstBrokerLoginFlowAlias": "first broker login",
            "config": {
              "clientId": "'"${OIDC_CLIENT_ID}"'",
              "clientSecret": "'"${OIDC_CLIENT_SECRET}"'",
              "issuer": "'"${OIDC_ISSUER}"'",
              "authorizationUrl": "'"${OIDC_AUTH_ENDPOINT}"'",
              "tokenUrl": "'"${OIDC_TOKEN_ENDPOINT}"'",
              "userInfoUrl": "'"${OIDC_USERINFO_ENDPOINT}"'",
              "jwksUrl": "'"${OIDC_JWKS_URI}"'",
              "backchannelSupported": "false",
              "validateSignature": "true",
              "useJwksUrl": "true",
              "pkceEnabled": "true",
              "pkceMethod": "S256",
              "syncMode": "IMPORT",
              "clientAuthMethod": "client_secret_basic",
              "defaultScope": "openid profile email"
            }
          }'

          if [ "$IDP_EXISTS" = "200" ]; then
            echo "IDP already exists, updating..."
            curl -sf -X PUT "${KEYCLOAK_URL}/admin/realms/master/identity-provider/instances/unifi-identity" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/json" \
              -d "${IDP_CONFIG}"
            echo "IDP updated successfully"
          else
            echo "Creating new IDP..."
            curl -sf -X POST "${KEYCLOAK_URL}/admin/realms/master/identity-provider/instances" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/json" \
              -d "${IDP_CONFIG}"
            echo "IDP created successfully"
          fi

          # Configure IDP mapper to auto-assign admin role
          echo ""
          echo "Configuring role mapper for admin access..."

          # Mapper configuration using oidc-hardcoded-role-idp-mapper (correct type for OIDC IDPs)
          MAPPER_CONFIG='{
            "name": "admin-role-mapper",
            "identityProviderMapper": "oidc-hardcoded-role-idp-mapper",
            "identityProviderAlias": "unifi-identity",
            "config": {
              "syncMode": "INHERIT",
              "role": "admin"
            }
          }'

          # Check if admin-role-mapper exists
          echo "Checking existing mappers..."
          MAPPERS=$(curl -s "${KEYCLOAK_URL}/admin/realms/master/identity-provider/instances/unifi-identity/mappers" \
            -H "Authorization: Bearer ${TOKEN}")

          MAPPER_EXISTS=$(echo "$MAPPERS" | grep -c '"name":"admin-role-mapper"' || true)

          if [ "$MAPPER_EXISTS" -gt 0 ]; then
            echo "Role mapper already exists, skipping creation."
          else
            echo "Creating role mapper..."
            RESULT=$(curl -s -w "\n%{http_code}" -X POST "${KEYCLOAK_URL}/admin/realms/master/identity-provider/instances/unifi-identity/mappers" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/json" \
              -d "${MAPPER_CONFIG}")
            HTTP_CODE=$(echo "$RESULT" | tail -1)
            if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ]; then
              echo "Role mapper created successfully"
            else
              echo "Warning: Failed to create mapper (HTTP $HTTP_CODE)"
              echo "Users can be assigned admin role manually in Keycloak admin console"
            fi
          fi

          # Assign admin role to all existing users from unifi-identity IDP
          echo ""
          echo "Assigning admin role to existing Techsecoms SSO users..."

          # Get admin role ID
          ADMIN_ROLE=$(curl -s "${KEYCLOAK_URL}/admin/realms/master/roles/admin" \
            -H "Authorization: Bearer ${TOKEN}")
          ADMIN_ROLE_ID=$(echo "$ADMIN_ROLE" | sed 's/.*"id":"\([^"]*\)".*/\1/')

          if [ -z "$ADMIN_ROLE_ID" ]; then
            echo "Warning: Could not get admin role ID"
          else
            # Get all users linked to unifi-identity IDP
            USERS=$(curl -s "${KEYCLOAK_URL}/admin/realms/master/users?max=1000" \
              -H "Authorization: Bearer ${TOKEN}")

            # Extract user IDs (simple parsing)
            echo "$USERS" | tr ',' '\n' | grep '"id"' | sed 's/.*"id":"\([^"]*\)".*/\1/' | while read USER_ID; do
              if [ -n "$USER_ID" ]; then
                # Check if user is linked to unifi-identity
                FEDERATED=$(curl -s "${KEYCLOAK_URL}/admin/realms/master/users/${USER_ID}/federated-identity" \
                  -H "Authorization: Bearer ${TOKEN}")

                if echo "$FEDERATED" | grep -q "unifi-identity"; then
                  # Check if user already has admin role
                  USER_ROLES=$(curl -s "${KEYCLOAK_URL}/admin/realms/master/users/${USER_ID}/role-mappings/realm" \
                    -H "Authorization: Bearer ${TOKEN}")

                  if ! echo "$USER_ROLES" | grep -q '"name":"admin"'; then
                    echo "Assigning admin role to user ${USER_ID}..."
                    curl -s -X POST "${KEYCLOAK_URL}/admin/realms/master/users/${USER_ID}/role-mappings/realm" \
                      -H "Authorization: Bearer ${TOKEN}" \
                      -H "Content-Type: application/json" \
                      -d "[${ADMIN_ROLE}]"
                  fi
                fi
              fi
            done
            echo "Admin role assignment complete"
          fi

          echo ""
          echo "Configuring realm default post-logout redirect URI..."

          # Get current realm config and add defaultPostLogoutRedirectUri
          REALM_CONFIG=$(curl -s "${KEYCLOAK_URL}/admin/realms/master" \
            -H "Authorization: Bearer ${TOKEN}")

          if ! echo "$REALM_CONFIG" | grep -q "defaultPostLogoutRedirectUri"; then
            echo "Adding defaultPostLogoutRedirectUri to realm..."
            UPDATED_REALM=$(printf '%s' "$REALM_CONFIG" | sed 's/"attributes":{/"attributes":{"defaultPostLogoutRedirectUri":"https:\/\/keycloak.ops.techsecom.io\/",/')
            RESULT=$(curl -s -w "\n%{http_code}" -X PUT "${KEYCLOAK_URL}/admin/realms/master" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$UPDATED_REALM")
            HTTP_CODE=$(echo "$RESULT" | tail -1)
            if [ "$HTTP_CODE" = "204" ]; then
              echo "Realm updated with defaultPostLogoutRedirectUri"
            else
              echo "Warning: Failed to update realm (HTTP $HTTP_CODE)"
            fi
          else
            echo "defaultPostLogoutRedirectUri already configured"
          fi

          echo ""
          echo "Configuring post-logout redirect URIs for built-in clients..."

          # Post-logout redirect URI - use + as wildcard to allow all redirects
          # In Keycloak, a single + means "allow any redirect URI"
          LOGOUT_URI="+"

          # Function to update client post-logout redirect URI
          update_client_logout_uri() {
            CLIENT_ID_NAME="$1"

            # Get client list and extract UUID using awk (more reliable than sed for JSON)
            CLIENT_DATA=$(curl -s "${KEYCLOAK_URL}/admin/realms/master/clients?clientId=${CLIENT_ID_NAME}" \
              -H "Authorization: Bearer ${TOKEN}")
            CLIENT_UUID=$(echo "$CLIENT_DATA" | awk -F'"' '{print $4}')

            # Validate UUID format (36 chars with dashes)
            if [ -z "$CLIENT_UUID" ] || [ ${#CLIENT_UUID} -ne 36 ]; then
              echo "Warning: Could not find valid UUID for ${CLIENT_ID_NAME}"
              return
            fi

            echo "Updating ${CLIENT_ID_NAME} (UUID: ${CLIENT_UUID})..."

            # Get current client config
            CURRENT_CONFIG=$(curl -s "${KEYCLOAK_URL}/admin/realms/master/clients/${CLIENT_UUID}" \
              -H "Authorization: Bearer ${TOKEN}")

            if echo "$CURRENT_CONFIG" | grep -q "error"; then
              echo "Warning: Could not get ${CLIENT_ID_NAME} config"
              return
            fi

            # Escape URL for sed replacement
            ESCAPED_URI=$(printf '%s' "$LOGOUT_URI" | sed 's/[\/&]/\\&/g')

            # Update or add post.logout.redirect.uris
            if echo "$CURRENT_CONFIG" | grep -q "post.logout.redirect.uris"; then
              # Replace existing value
              UPDATED=$(printf '%s' "$CURRENT_CONFIG" | sed "s/\"post\.logout\.redirect\.uris\":\"[^\"]*\"/\"post.logout.redirect.uris\":\"${ESCAPED_URI}\"/")
            else
              # Add new attribute
              UPDATED=$(printf '%s' "$CURRENT_CONFIG" | sed "s/\"attributes\":{/\"attributes\":{\"post.logout.redirect.uris\":\"${ESCAPED_URI}\",/")
            fi

            # Apply update
            RESULT=$(curl -s -w "\n%{http_code}" -X PUT "${KEYCLOAK_URL}/admin/realms/master/clients/${CLIENT_UUID}" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$UPDATED")
            HTTP_CODE=$(echo "$RESULT" | tail -1)

            if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
              echo "${CLIENT_ID_NAME} updated successfully"
            else
              echo "Warning: Failed to update ${CLIENT_ID_NAME} (HTTP ${HTTP_CODE})"
            fi

            # Enable frontchannelLogout for proper logout flow
            if echo "$CURRENT_CONFIG" | grep -q '"frontchannelLogout":false'; then
              echo "Enabling frontchannelLogout for ${CLIENT_ID_NAME}..."
              UPDATED_FC=$(printf '%s' "$CURRENT_CONFIG" | sed 's/"frontchannelLogout":false/"frontchannelLogout":true/')
              curl -s -X PUT "${KEYCLOAK_URL}/admin/realms/master/clients/${CLIENT_UUID}" \
                -H "Authorization: Bearer ${TOKEN}" \
                -H "Content-Type: application/json" \
                -d "$UPDATED_FC" > /dev/null && echo "frontchannelLogout enabled"
            fi
          }

          # Update built-in clients with post-logout redirect URIs and frontchannelLogout
          update_client_logout_uri "account-console"
          update_client_logout_uri "security-admin-console"
          update_client_logout_uri "account"

          echo ""
          echo "OIDC Identity Provider setup complete!"
{{- end }}
